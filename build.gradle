description = 'Gradle wrapper for OpenSSL build'

apply plugin: 'base'

import org.gradle.internal.os.OperatingSystem

buildscript {
    ext.svtFunctionsVersion = '5.0.2'

    repositories {
        mavenLocal()
        maven {
            name "ArtifactoryRepo"
            // see gradle.properties
            url artifactoryUrl
        }
    }

    dependencies {
        classpath "com.simplivity.gradle.plugins:gradle-svtfunctions-plugin:$svtFunctionsVersion"
    }
}

group = "openssl"

apply plugin: 'com.simplivity.svt-functions'

artifactoryPublish.skip = true

artifactory {
    publish {
        defaults {
            publications('OpenSSLNar')
        }
    }
}

if (OperatingSystem.current().linux) {
    ext.buildPlatform = 'linux_x64'
} else {
    ext.buildPlatform = 'windows_x64'
}

[ 'Shared' ].each { type ->
    [ 'Debug', 'RelWithDebInfo' ].each { mode ->
        if (OperatingSystem.current().linux) {
            tasks.create(name: "makeLinux${type}${mode}", group: 'Build') {
                description = "Generates the Linux ${type} ${mode} configuration"
                doLast {
                    exec { executable 'util/buildFOM.sh' args "${type}", "${mode}"}
                    exec { executable 'make' args 'test' }
                    exec { executable 'make' args 'install_sw' }
                }
            }

            tasks.create("assembleLinux${type}${mode}Nar", Zip).configure {
                def clMode = mode == 'RelWithDebInfo' ? 'release' : mode
                group = 'Build'
                description = "Assembles a zip archive containing the OpenSSL Linux ${type} ${mode} library."
                dependsOn "makeLinux${type}${mode}"

                baseName = 'openssl'
                classifier = "linux_x64-${type.toLowerCase()}-${clMode.toLowerCase()}"
                extension = 'nar'
                destinationDir = file("$buildDir/distributions")

                from("$buildDir/${type}/${mode}/include") {
                    into 'include'
                }
                from("$buildDir/${type}/${mode}/lib") {
                    into 'lib'
                }
                from("$buildDir/${type}/${mode}/bin") {
                    into 'bin'
                }
            }
        } else {
		//TODO: Windows support
        }
    }
}

assemble.dependsOn assembleLinuxSharedDebugNar
assemble.dependsOn assembleLinuxSharedRelWithDebInfoNar

def ivyUrl = "${System.properties['user.home']}/.ivy/repository"
if (project.hasProperty('ivyLocalUrl')) {
    ivyUrl = project.ivyLocalUrl
}


publishing {
    publications {
        OpenSSLNar(IvyPublication) {
            module 'openssl'
            configurations {
                "${buildPlatform}-shared-debug" {}
                "${buildPlatform}-shared-release" {}
                "default" {}
            }
            artifact(assembleLinuxSharedDebugNar) {
                conf "${buildPlatform}-shared-debug"
            }
            artifact(assembleLinuxSharedRelWithDebInfoNar) {
                conf "${buildPlatform}-shared-release"
            }
            descriptor.withXml {
                asNode().info[0].appendNode('description', 'openssl library')
                mergeIvyDescriptor(asNode())
            }
        }
    }
    repositories {
        ivy {
            name "IvyLocal"
            url ivyUrl
            layout 'gradle'
        }
    }
}

def mergeIvyDescriptor(ivyModuleNode) {
    // NOTE: This is controlled by the Jenkins job configuration!!!
    // We use the "Copy Artifacts" plugin to make the sequentially
    // building Linux build resulting ivy.xml available to the Windows
    // builds to merge and consolidate the two descriptors.
    def linuxIvy = rootProject.file('ivyDescriptor/ivy.xml')
    if (linuxIvy.exists()) {
        def ivyModule = new XmlSlurper().parse(linuxIvy)

        mergeConfigurations(ivyModuleNode.configurations[0], ivyModule.configurations[0].childNodes())
        mergePublications(ivyModuleNode.publications[0], ivyModule.publications[0].childNodes())
    }
}

def mergeConfigurations(myConf, toBeMergedConf) {
    toBeMergedConf.each {
        if (it.attributes()['name'] == 'default') {
            def myDef = myConf.children().find { it.@name == 'default' }
            if (myDef) {
                def mergingValue = it.attributes()['extends']
                if (mergingValue) {
                    if (myDef.@extends) {
                        myDef.@extends = myDef.@extends + ',' + mergingValue
                    } else {
                        myDef.@extends = mergingValue
                    }
                }
            } else {
                myConf.appendNode(it.name(), it.attributes())
            }
        } else {
            myConf.appendNode(it.name(), it.attributes())
        }
    }
}


def mergePublications(myPubs, linuxPubs) {
    linuxPubs.each {
        myPubs.appendNode(it.name(), fixupAttributes(it.attributes()))
    }
}

// XML HACK! This does not seem like the best way but the result
// proves it works. The Ivy descriptor is formatted as it should be.
// For some reason the attributes map returned by the XMLSlurper nodes
// has the names stringified which is unfortunate. The nodes we handle
// can use a QName instead of a string in the map keys just the same.
def fixupAttributes(attributes) {
    def attr = [:]
    attributes.each { k,v ->
        if (k == '{http://ant.apache.org/ivy/maven}classifier') {
            k = new groovy.xml.QName('http://ant.apache.org/ivy/maven', 'classifier', 'm')
        }
        attr.put(k, v)
    }
    return attr
}
